
import React, { useState, useEffect, useMemo } from 'react';
import Papa from 'papaparse';
import { Nft, TraitDetail, TraitMap, Filters } from './types';
import { TRAIT_CATEGORIES, NEW_NFT_DATA_URL, NEW_SUPPLY_COUNT_URL } from './constants';
import { getTraitKey, getTraitThumbnailUrl, getRarityFromSupply, getNftRarity, checkIpRisk } from './utils';
import { NFTCard } from './components/NFTCard';
import { NFTModal } from './components/NFTModal';
import { TraitDetailModal } from './components/TraitDetailModal';
import { FilterSidebar } from './components/FilterSidebar';
import { FilterIcon, GridIcon, BookIcon, CautionIcon } from './components/icons';

// Encyclopedia Component
interface EncyclopediaProps {
  traitDetails: TraitMap;
  onTraitClick: (category: string, traitName: string) => void;
}

const Encyclopedia: React.FC<EncyclopediaProps> = ({ traitDetails, onTraitClick }) => {
  const traitsByCategory = useMemo(() => {
    const grouped: Record<string, TraitDetail[]> = {};
    TRAIT_CATEGORIES.forEach(cat => grouped[cat] = []);
    
    (Object.values(traitDetails) as TraitDetail[]).forEach(detail => {
      if (detail.Category && grouped[detail.Category]) {
        grouped[detail.Category].push(detail);
      }
    });

    Object.keys(grouped).forEach(cat => {
      grouped[cat].sort((a, b) => {
          const supplyA = parseInt(a.Supply, 10) || 999;
          const supplyB = parseInt(b.Supply, 10) || 999;
          if (supplyA !== supplyB) return supplyA - supplyB;
          return a['Unique Item List'].localeCompare(b['Unique Item List']);
      });
    });

    return grouped;
  }, [traitDetails]);

  const getRarityColor = (tier: string) => {
    switch(tier) {
        case 'Grail': return '#DC2626';
        case 'Legendary': return '#F97316';
        case 'Epic': return '#9333EA';
        case 'Rare': return '#16A34A';
        case 'Uncommon': return '#B45309';
        default: return '#9CA3AF';
    }
  };

  return (
    <div className="space-y-8">
      {TRAIT_CATEGORIES.map(category => (
        <div key={category} className="bg-white rounded-xl shadow-md overflow-hidden">
          <div className="bg-gradient-to-r from-purple-800 to-gray-700 px-6 py-4">
             <h2 className="text-2xl font-bold text-white font-serif">{category}</h2>
          </div>
          <div className="p-6 grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 lg:grid-cols-5 gap-4">
            {traitsByCategory[category]?.map((trait) => {
               const { tier } = getRarityFromSupply(trait.Supply);
               const hasIpRisk = checkIpRisk(trait['IP Risk']);

               return (
                 <div 
                    key={trait['Unique Item List']}
                    onClick={() => onTraitClick(category, trait['Unique Item List'])}
                    className="border border-gray-200 rounded-lg p-3 hover:shadow-lg transition-shadow cursor-pointer flex flex-col items-center text-center bg-gray-50 hover:bg-white relative group"
                 >
                    {hasIpRisk && <div className="absolute top-2 right-2 z-10 text-yellow-500" title="IP Risk"><CautionIcon className="w-4 h-4" /></div>}
                    
                    <div className="w-full aspect-square rounded-md mb-2 overflow-hidden flex items-center justify-center bg-white border border-gray-100">
                        {trait.thumbnailUrl ? (
                            <img src={trait.thumbnailUrl} alt={trait['Unique Item List']} className="w-full h-full object-contain" loading="lazy" />
                        ) : (
                            <span className="text-gray-300 text-xs">No Image</span>
                        )}
                    </div>
                    
                    <div className="w-full">
                        <div className="text-sm font-bold truncate w-full" title={trait['Unique Item List']}>{trait['Unique Item List']}</div>
                        <div className="flex items-center justify-between mt-1">
                             <span className="text-xs text-gray-500 font-mono">Qty: {trait.Supply}</span>
                             <div className="w-2 h-2 rounded-full" style={{ backgroundColor: getRarityColor(tier) }} title={tier}></div>
                        </div>
                    </div>
                 </div>
               );
            })}
            {(!traitsByCategory[category] || traitsByCategory[category].length === 0) && (
                <div className="col-span-full text-center text-gray-400 py-4">No items found in this category.</div>
            )}
          </div>
        </div>
      ))}
    </div>
  );
};

const App: React.FC = () => {
  const [currentView, setCurrentView] = useState<'gallery' | 'encyclopedia'>('gallery');
  const [nfts, setNfts] = useState<Nft[]>([]);
  const [traitDetails, setTraitDetails] = useState<TraitMap>({});
  const [loading, setLoading] = useState<boolean>(true);
  const [error, setError] = useState<string | null>(null);
  const [selectedNft, setSelectedNft] = useState<Nft | null>(null);
  const [selectedTrait, setSelectedTrait] = useState<TraitDetail | null>(null);
  const [isSidebarOpen, setIsSidebarOpen] = useState<boolean>(false);
  const [filters, setFilters] = useState<Filters>({ id: '', rarity: '', traits: {}, showIpRisk: false });
  const [idInput, setIdInput] = useState<string>('');

  useEffect(() => {
    const loadData = async () => {
      try {
        setLoading(true);
        const [nftRes, traitRes] = await Promise.all([
          fetch(NEW_NFT_DATA_URL),
          fetch(NEW_SUPPLY_COUNT_URL)
        ]);
        if (!nftRes.ok || !traitRes.ok) throw new Error('Failed to fetch data from GitHub.');
        
        const nftText = await nftRes.text();
        const traitText = await traitRes.text();
        
        const traitMap: TraitMap = await new Promise((resolve, reject) => {
          Papa.parse<TraitDetail>(traitText, {
            header: true, skipEmptyLines: true,
            complete: (results) => {
              const map: TraitMap = {};
              results.data.forEach(d => {
                // Find Category and Item Name columns if standard names aren't found
                const keys = Object.keys(d);
                let categoryVal = d.Category;
                let itemListVal = d['Unique Item List'];

                if (!categoryVal || !itemListVal) {
                   // Fallback logic for weird headers
                   const catKey = keys.find(k => k.trim().toLowerCase() === 'category');
                   const itemKey = keys.find(k => ['unique item list', 'item name', 'trait name'].includes(k.trim().toLowerCase()));
                   if (catKey) categoryVal = d[catKey];
                   if (itemKey) itemListVal = d[itemKey];
                }

                if (categoryVal && itemListVal) {
                  // Normalize Category Names
                  let category = categoryVal.trim();
                  const lowerCat = category.toLowerCase();
                  
                  if (lowerCat === 'head' || lowerCat === 'hats') category = 'Headwear';
                  else if (lowerCat === 'face' || lowerCat === 'glasses') category = 'Eyewear';
                  else if (lowerCat === 'mouth') category = 'Mouth Items';
                  else if (lowerCat === 'torso' || lowerCat === 'clothing' || lowerCat === 'shirt') category = 'Clothes';
                  else if (lowerCat === 'base' || lowerCat === 'body') category = 'Bro Type';
                  
                  const key = getTraitKey(category, itemListVal);
                  
                  if (key) {
                    const thumbFile = d.ThumbFilename || d.IconName;
                    
                    // 1. Check for "IP Concern" specifically as requested
                    // 2. Fallback to "IP Risk"
                    // 3. Fallback to fuzzy search
                    let ipRiskVal = d['IP Concern'] || d['IP Risk'];
                    
                    if (ipRiskVal === undefined) {
                        const riskKey = keys.find(k => {
                            const clean = k.trim().toLowerCase();
                            return clean === 'ip concern' || clean === 'ip risk' || clean.includes('ip concern') || clean.includes('ip risk');
                        });
                        if (riskKey) ipRiskVal = d[riskKey];
                    }

                    map[key] = { 
                      ...d, 
                      Category: category, 
                      'IP Risk': ipRiskVal, // Store under standard key for checking
                      'Unique Item List': itemListVal.trim(),
                      thumbnailUrl: getTraitThumbnailUrl(category, thumbFile, itemListVal) 
                    };
                  }
                }
              });
              resolve(map);
            },
            error: (err) => reject(new Error(`Failed to parse trait data: ${err.message}`))
          });
        });

        await new Promise<void>((resolve, reject) => {
          Papa.parse<any>(nftText, {
            header: true, dynamicTyping: true, skipEmptyLines: true,
            complete: (results) => {
              const enriched = results.data.filter(n => n.ID).map((n: any): Nft => {
                const enrichedNft: any = { ...n };
                let hasRisk = false;
                
                // Identify keys in the NFT data that correspond to our categories
                const nftKeys = Object.keys(n);
                
                TRAIT_CATEGORIES.forEach(cat => {
                  // Try exact match first, then case-insensitive match
                  let keyInNft = cat;
                  if (n[cat] === undefined) {
                      keyInNft = nftKeys.find(k => k.trim().toLowerCase() === cat.toLowerCase()) || cat;
                  }
                  
                  // Also handle mapping "Head" in NFT csv to "Headwear" category
                  if (n[keyInNft] === undefined) {
                       if (cat === 'Headwear') keyInNft = nftKeys.find(k => k.trim().toLowerCase() === 'head') || keyInNft;
                       if (cat === 'Bro Type') keyInNft = nftKeys.find(k => k.trim().toLowerCase() === 'body' || k.trim().toLowerCase() === 'base') || keyInNft;
                       if (cat === 'Clothes') keyInNft = nftKeys.find(k => k.trim().toLowerCase() === 'torso' || k.trim().toLowerCase() === 'clothing') || keyInNft;
                       if (cat === 'Eyewear') keyInNft = nftKeys.find(k => k.trim().toLowerCase() === 'face' || k.trim().toLowerCase() === 'glasses') || keyInNft;
                       if (cat === 'Mouth Items') keyInNft = nftKeys.find(k => k.trim().toLowerCase() === 'mouth') || keyInNft;
                  }

                  const value = n[keyInNft];
                  if (value && value !== 'None') {
                    const name = String(value).split(' (')[0].trim();
                    const key = getTraitKey(cat, name);
                    const detail = key ? traitMap[key] : undefined;
                    
                    // Update the NFT object with standard category key for consistent access
                    if (detail) {
                        enrichedNft[cat] = `${name} (${detail.Supply})`;
                        if (checkIpRisk(detail['IP Risk'])) hasRisk = true;
                    } else {
                        // Even if no supply detail, ensure the trait is accessible via standard key
                        enrichedNft[cat] = name; 
                    }
                  }
                });
                enrichedNft.hasIpRisk = hasRisk;
                return enrichedNft;
              });
              setNfts(enriched);
              setTraitDetails(traitMap);
              resolve();
            },
            error: (err) => reject(new Error(`Failed to parse NFT data: ${err.message}`))
          });
        });
      } catch (err) {
        console.error(err);
        setError(err instanceof Error ? err.message : 'An unknown error occurred');
      } finally {
        setLoading(false);
      }
    };
    loadData();
  }, []);

  useEffect(() => {
    const timer = setTimeout(() => setFilters(prev => ({ ...prev, id: idInput })), 300);
    return () => clearTimeout(timer);
  }, [idInput]);

  const filteredNfts = useMemo(() => {
    return nfts.filter(nft => {
      // DEFAULT BEHAVIOR: If showIpRisk is FALSE, HIDE items with hasIpRisk = TRUE.
      if (!filters.showIpRisk && nft.hasIpRisk) return false;
      
      if (filters.id && nft.ID.toString() !== filters.id && filters.id !== '') return false;
      
      if (filters.rarity) {
        if (getNftRarity(nft).tier !== filters.rarity) return false;
      }
      for (const [cat, val] of Object.entries(filters.traits)) {
        if (nft[cat] !== val) return false;
      }
      return true;
    });
  }, [nfts, filters]);

  const facetedCounts = useMemo(() => {
    const counts = {
      rarity: {} as Record<string, number>,
      traits: {} as Record<string, Record<string, number>>
    };
    TRAIT_CATEGORIES.forEach(cat => counts.traits[cat] = {});

    const matchesFilters = (nft: Nft, excludeCategory?: string) => {
        if (!filters.showIpRisk && nft.hasIpRisk) return false;
        if (filters.id && nft.ID.toString() !== filters.id && filters.id !== '') return false;
        
        if (excludeCategory !== 'rarity' && filters.rarity) {
            if (getNftRarity(nft).tier !== filters.rarity) return false;
        }

        for (const [cat, val] of Object.entries(filters.traits)) {
            if (excludeCategory !== cat && val && nft[cat] !== val) return false;
        }
        return true;
    };

    nfts.forEach(nft => {
        if (matchesFilters(nft, 'rarity')) {
            const tier = getNftRarity(nft).tier;
            counts.rarity[tier] = (counts.rarity[tier] || 0) + 1;
        }
    });

    TRAIT_CATEGORIES.forEach(cat => {
        nfts.forEach(nft => {
            if (matchesFilters(nft, cat)) {
                const val = nft[cat];
                if (typeof val === 'string' && val && val !== 'None') {
                    counts.traits[cat][val] = (counts.traits[cat][val] || 0) + 1;
                }
            }
        });
    });

    return counts;
  }, [nfts, filters]);

  const traitOptions = useMemo(() => {
    const options: { [key: string]: string[] } = {};
    TRAIT_CATEGORIES.forEach(cat => {
      const values = new Set<string>();
      nfts.forEach(nft => {
        const val = nft[cat];
        if (typeof val === 'string' && val && val !== 'None') values.add(val);
      });
      options[cat] = Array.from(values).sort((a, b) => a.localeCompare(b));
    });
    return options;
  }, [nfts]);

  const handleTraitClick = (category: string, value: string) => {
    // value is likely "TraitName" or "TraitName (Supply)"
    const name = value.split(' (')[0].trim();
    const key = getTraitKey(category, name);
    if (key && traitDetails[key]) setSelectedTrait(traitDetails[key]);
  };
  
  const handleEncyclopediaClick = (category: string, traitName: string) => {
        const key = getTraitKey(category, traitName);
        if (key && traitDetails[key]) {
            const fullValue = `${traitName} (${traitDetails[key].Supply})`;
            const isRisky = checkIpRisk(traitDetails[key]['IP Risk']);
            
            // Clear all previous filters and apply only the new trait filter
            setFilters({
                id: '',
                rarity: '',
                traits: {
                    [category]: fullValue
                },
                // If the selected trait is risky, force show IP risk.
                // Otherwise, reset it to false (clean slate default).
                showIpRisk: isRisky
            });
            setCurrentView('gallery');
        }
  };

  const hiddenByIpRisk = useMemo(() => {
    if (idInput && filteredNfts.length === 0) {
        const nft = nfts.find(n => n.ID.toString() === idInput);
        if (nft && nft.hasIpRisk && !filters.showIpRisk) {
            return true;
        }
    }
    return false;
  }, [idInput, filteredNfts.length, nfts, filters.showIpRisk]);

  if (loading) return <div className="min-h-screen flex items-center justify-center"><div className="text-2xl font-bold text-purple-700 animate-pulse">Loading Hemi Bros...</div></div>;
  if (error) return <div className="min-h-screen flex items-center justify-center p-4"><div className="bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded relative text-center"><strong className="font-bold">Error!</strong><span className="block sm:inline ml-2">{error}</span></div></div>;

  return (
    <div className="min-h-screen flex flex-col">
        <header className="bg-gradient-to-r from-purple-800 to-gray-700 shadow-lg sticky top-0 z-20">
            <div className="container mx-auto px-4 py-3 flex flex-col md:flex-row items-center justify-between gap-4">
                <h1 className="text-3xl md:text-4xl font-bold text-white tracking-wider cursor-pointer" style={{ fontFamily: 'VT323, monospace' }} onClick={() => setCurrentView('gallery')}>HEMI BROS NFT GALLERY</h1>
                <div className="flex bg-gray-900/30 rounded-lg p-1">
                    <button 
                        onClick={() => setCurrentView('gallery')}
                        className={`px-4 py-1.5 rounded-md text-sm font-bold transition-all flex items-center ${currentView === 'gallery' ? 'bg-white text-purple-900 shadow' : 'text-gray-200 hover:text-white hover:bg-white/10'}`}
                    >
                        <GridIcon /> Gallery
                    </button>
                    <button 
                        onClick={() => setCurrentView('encyclopedia')}
                        className={`px-4 py-1.5 rounded-md text-sm font-bold transition-all flex items-center ${currentView === 'encyclopedia' ? 'bg-white text-purple-900 shadow' : 'text-gray-200 hover:text-white hover:bg-white/10'}`}
                    >
                        <BookIcon /> Encyclopedia
                    </button>
                </div>
            </div>
        </header>

        <main className="container mx-auto p-4 flex-grow">
            {currentView === 'gallery' ? (
                <>
                    <div className="sticky top-[72px] bg-[#d1d1d1] bg-opacity-90 backdrop-blur-sm z-10 py-4 mb-4">
                        <div className="flex justify-center">
                        <input type="search" value={idInput} onChange={e => setIdInput(e.target.value)} placeholder="Search by ID..." className="w-full max-w-xs px-4 py-2 border border-gray-300 rounded-full shadow-md focus:ring-2 focus:ring-purple-500 focus:outline-none"/>
                        </div>
                        <div className="text-center text-sm text-gray-600 mt-4">Showing <span className="font-bold">{filteredNfts.length}</span> of <span className="font-bold">{nfts.length}</span> NFTs</div>
                        
                        {hiddenByIpRisk && (
                            <div className="max-w-md mx-auto mt-4 bg-yellow-50 border-l-4 border-yellow-400 p-4 rounded shadow-md">
                                <div className="flex">
                                    <div className="flex-shrink-0">
                                        <CautionIcon className="h-5 w-5 text-yellow-400" />
                                    </div>
                                    <div className="ml-3">
                                        <p className="text-sm text-yellow-700">
                                            Item <span className="font-bold">#{idInput}</span> has been community flagged with one or more items that have IP risk.
                                        </p>
                                        <div className="mt-2">
                                            <button 
                                                onClick={() => setFilters(prev => ({ ...prev, showIpRisk: true }))}
                                                className="text-sm font-medium text-yellow-800 hover:text-yellow-900 underline"
                                            >
                                                Show IP Risk Content
                                            </button>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        )}
                    </div>
                    
                    <div className="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 lg:grid-cols-5 xl:grid-cols-6 gap-4">
                    {filteredNfts.map(nft => <NFTCard key={nft.ID} nft={nft} onClick={setSelectedNft} />)}
                    </div>
                    
                    {filteredNfts.length === 0 && !hiddenByIpRisk && (
                        <div className="col-span-full text-center py-12 text-gray-500"><h3 className="text-xl font-semibold">No NFTs Found</h3><p>Try adjusting your filters.</p></div>
                    )}
                </>
            ) : (
                <Encyclopedia traitDetails={traitDetails} onTraitClick={handleEncyclopediaClick} />
            )}
        </main>

        {currentView === 'gallery' && (
            <>
                <button onClick={() => setIsSidebarOpen(true)} aria-label="Open filters" className="fixed bottom-5 right-5 bg-gradient-to-br from-yellow-400 to-amber-600 text-white p-4 rounded-full shadow-xl hover:scale-110 active:scale-100 transition-transform z-10"><FilterIcon /></button>
                <FilterSidebar 
                    isOpen={isSidebarOpen} 
                    onClose={() => setIsSidebarOpen(false)} 
                    filters={filters} 
                    setFilters={setFilters} 
                    traitOptions={traitOptions} 
                    traitDetails={traitDetails}
                    facetedCounts={facetedCounts}
                />
            </>
        )}
        
        <NFTModal 
            nft={selectedNft} 
            traitDetails={traitDetails}
            onClose={() => setSelectedNft(null)} 
            onTraitClick={handleTraitClick} 
        />
    </div>
  );
};
export default App;
